generator client {
  provider = "prisma-client"
  output   = "generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============= ENUMS (Only for fixed types) =============

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum BloodGroup {
  A_POSITIVE
  A_NEGATIVE
  B_POSITIVE
  B_NEGATIVE
  AB_POSITIVE
  AB_NEGATIVE
  O_POSITIVE
  O_NEGATIVE
}

enum AppointmentType {
  NEW
  FOLLOWUP
}

enum AppointmentStatus {
  WAITING
  IN_CONSULTATION
  COMPLETED
  CANCELLED
}

enum BillStatus {
  PENDING
  PARTIAL
  PAID
  REFUNDED
  CANCELLED
}

enum TestStatus {
  ORDERED
  BILLED
  IN_PROGRESS
  COMPLETED
  REVIEWED
  RELEASED
  DELIVERED
  CANCELLED
}

enum PaymentMethod {
  CASH
  CARD
  MOBILE_BANKING
  ONLINE
}

enum NotificationType {
  APPOINTMENT
  TEST_READY
  PAYMENT
  QUEUE_UPDATE
  SYSTEM
}

enum AppointmentEventType {
  // Appointment Registration
  APPOINTMENT_REGISTERED
  APPOINTMENT_ASSIGNED

  // Queue Management
  QUEUE_JOINED
  QUEUE_CALLED
  QUEUE_SKIPPED

  // Consultation Flow
  ENTERED_ROOM
  EXITED_ROOM
  CONSULTATION_COMPLETED

  // Clinical Actions
  PRESCRIPTION_GIVEN
  TESTS_ORDERED
  REFERRAL_GIVEN

  // Billing Events
  CONSULTATION_BILLED
  TESTS_BILLED
  PAYMENT_RECEIVED
  PAYMENT_PARTIAL
  PAYMENT_REFUNDED

  // Lab/Test Workflow
  TEST_SAMPLE_COLLECTED
  TEST_IN_PROGRESS
  TEST_COMPLETED
  TEST_REVIEWED
  TEST_APPROVED
  REPORT_GENERATED
  REPORT_DELIVERED

  // Document Events
  DOCUMENT_UPLOADED
  DOCUMENT_SHARED

  // Appointment Completion
  APPOINTMENT_COMPLETED
  APPOINTMENT_CANCELLED
  APPOINTMENT_RESCHEDULED

  // Follow-up
  FOLLOWUP_SCHEDULED
  FOLLOWUP_REMINDER_SENT
}

// ============= USERS & AUTH =============

model users {
  id            String   @id @default(ulid())
  name          String
  email         String   @unique
  emailVerified Boolean  @default(false)
  password      String?
  phone         String?
  avatar        String?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  userRoles       user_roles[]
  employeeProfile employees?
  sessions        sessions[]
  accounts        accounts[]      @relation("UserAccounts")
  documents       documents[]
  notifications   notifications[]

  @@index([email])
  @@index([isActive])
}

model sessions {
  id        String   @id @default(ulid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user users @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
}

model accounts {
  id                    String    @id @default(ulid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user users @relation("UserAccounts", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, providerId])
  @@index([userId])
  @@index([providerId])
}

model verifications {
  id         String   @id @default(ulid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
  @@index([identifier])
}

// ============= ROLES & PERMISSIONS =============

model roles {
  id          String   @id @default(ulid())
  name        String   @unique
  slug        String   @unique
  description String?
  isSystem    Boolean  @default(false) // true for SUPER_ADMIN, ADMIN, DOCTOR, etc.
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userRoles       user_roles[]
  rolePermissions role_permissions[]

  @@index([slug])
  @@index([isSystem])
  @@index([isActive])
}

model permissions {
  id          String   @id @default(ulid())
  name        String   @unique
  slug        String   @unique
  module      String // "patients", "visits", "billing", "labs", etc.
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  rolePermissions role_permissions[]

  @@index([slug])
  @@index([module])
}

model role_permissions {
  id           String @id @default(ulid())
  roleId       String
  permissionId String

  role       roles       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission permissions @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

model user_roles {
  id     String @id @default(ulid())
  userId String
  roleId String

  user users @relation(fields: [userId], references: [id], onDelete: Cascade)
  role roles @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

// ============= DEPARTMENTS =============

model departments {
  id          String   @id @default(ulid())
  name        String   @unique
  code        String   @unique
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  employeeDepartments employee_departments[]
  labs                labs[]

  @@index([code])
  @@index([isActive])
}

// ============= SPECIALIZATIONS =============

model specializations {
  id          String   @id @default(ulid())
  name        String   @unique
  code        String   @unique
  description String?  @db.Text
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  employeeSpecializations employee_specializations[]

  @@index([code])
  @@index([isActive])
}

// ============= EMPLOYEES (Doctors, Nurses, Staff, etc.) =============

model employees {
  id            String  @id @default(ulid())
  userId        String  @unique
  bio           String? @db.Text
  qualification String? @db.Text
  experiences   Json? // Array of {company, designation, startDate, endDate, description}
  certificates  Json? // Array of certificate objects
  documents     Json? // File uploads metadata

  // Doctor/Medical Staff specific
  consultationFee Float?
  hospitalFee     Float?  @default(0)
  isAvailable     Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                    users                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  employeeDepartments     employee_departments[]
  employeeSpecializations employee_specializations[]
  doctorAppointments      appointments[]             @relation("DoctorAppointments")
  assignedAppointments    appointments[]             @relation("AssignedAppointments")
  prescriptions           prescriptions[]
  testResults             test_results[]             @relation("Technician")
  reviewedTests           test_results[]             @relation("Reviewer")
  orderedTests            test_orders[]              @relation("OrderedBy")
  receivedPayments        payments[]
  appointmentEvents       appointment_events[]       @relation("PerformedBy")

  @@index([userId])
  @@index([isAvailable])
}

// ============= JUNCTION TABLES =============

// Many-to-many: Employees <-> Departments
model employee_departments {
  id           String   @id @default(ulid())
  employeeId   String
  departmentId String
  isPrimary    Boolean  @default(false) // Mark one department as primary
  createdAt    DateTime @default(now())

  employee   employees   @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  department departments @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  @@unique([employeeId, departmentId])
  @@index([employeeId])
  @@index([departmentId])
}

// Many-to-many: Employees <-> Specializations
model employee_specializations {
  id               String   @id @default(ulid())
  employeeId       String
  specializationId String
  createdAt        DateTime @default(now())

  employee       employees       @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  specialization specializations @relation(fields: [specializationId], references: [id], onDelete: Cascade)

  @@unique([employeeId, specializationId])
  @@index([employeeId])
  @@index([specializationId])
}

// ============= PATIENTS =============

model patients {
  id         String      @id @default(ulid())
  patientId  String      @unique
  name       String
  age        Int
  phone      String
  gender     Gender?
  address    String?
  bloodGroup BloodGroup?
  email      String?
  notes      String?
  isActive   Boolean     @default(true)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  appointments appointments[]
  documents    documents[]
  bills        bills[]

  @@index([patientId])
  @@index([phone])
  @@index([name])
  @@index([isActive])
  @@index([createdAt]) // For recent patients
}

// ============= APPOINTMENTS =============

model appointments {
  id             String      @id @default(ulid())
  patientId      String
  doctorId       String // References employees.id
  assignedBy     String // References employees.id
  appointmentType AppointmentType
  chiefComplaint  String?          @db.Text
  diagnosis       String?          @db.Text
  serialNumber    Int
  queuePosition   Int
  status          AppointmentStatus @default(WAITING)
  entryTime      DateTime?
  exitTime       DateTime?
  appointmentDate DateTime    @default(now())
  appointmentMonth String // YYYY-MM for partitioning/archiving
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  patient            patients        @relation(fields: [patientId], references: [id])
  doctor             employees       @relation("DoctorAppointments", fields: [doctorId], references: [id])
  assignedByEmployee employees       @relation("AssignedAppointments", fields: [assignedBy], references: [id])
  bills              bills[]
  prescriptions      prescriptions[]
  testOrders         test_orders[]
  appointmentEvents  appointment_events[]

  @@index([doctorId, appointmentDate, queuePosition]) // Queue management
  @@index([patientId, appointmentDate]) // Patient history
  @@index([status, appointmentDate]) // Today's waiting/in-consultation
  @@index([appointmentDate]) // Daily operations
  @@index([appointmentMonth]) // Monthly partitioning
  @@index([createdAt]) // Recent appointments
  @@index([status]) // Status filtering (all WAITING appointments)
  @@index([doctorId, status]) // Doctor's appointments by status
  @@unique([doctorId, appointmentDate, serialNumber]) // Prevent duplicate serial numbers
  @@unique([doctorId, appointmentDate, queuePosition]) // Prevent duplicate queue positions
}

// ============= APPOINTMENT EVENTS (Event Sourcing Pattern) =============

model appointment_events {
  id            String         @id @default(ulid())
  appointmentId String
  eventType   AppointmentEventType
  description String?
  metadata    Json? // Flexible data: billId, testId, fileUrl, duration, etc.
  performedBy String? // References employees.id
  performedAt DateTime       @default(now())
  createdAt   DateTime       @default(now())

  appointment         appointments @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  performedByEmployee employees?   @relation("PerformedBy", fields: [performedBy], references: [id])

  @@index([appointmentId, performedAt]) // Timeline reconstruction
  @@index([eventType]) // Event type filtering
  @@index([performedAt]) // Chronological queries
  @@index([appointmentId, eventType]) // Specific event lookup
}

// ============= BILLING (Polymorphic-like Design) =============

model bills {
  id           String     @id @default(ulid())
  billNumber      String     @unique
  patientId       String
  appointmentId   String?
  billableType String? // "appointment", "test", "medicine", "other" - flexible for future
  billableId   String? // ID of the billable entity
  totalAmount  Float
  paidAmount   Float      @default(0)
  dueAmount    Float
  discount     Float      @default(0)
  status       BillStatus @default(PENDING)
  billingDate  DateTime   @default(now())
  dueDate      DateTime?
  notes        String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  patient     patients      @relation(fields: [patientId], references: [id])
  appointment appointments? @relation(fields: [appointmentId], references: [id])
  billItems bill_items[]
  payments  payments[]

  @@index([billNumber])
  @@index([patientId, status]) // Patient's pending bills
  @@index([appointmentId])
  @@index([status, billingDate]) // Pending bills by date
  @@index([billableType, billableId]) // Polymorphic lookup
  @@index([billingDate]) // Daily billing reports
  @@index([createdAt]) // Recent bills
  @@index([dueAmount]) // Overdue bills filtering
  @@index([status, dueAmount]) // Complex overdue queries
}

model bill_items {
  id           String  @id @default(ulid())
  billId       String
  itemableType String // "consultation", "test", "medicine", "service" - polymorphic
  itemableId   String // ID of the item (test_order.id, medicine.id, etc.)
  itemName     String
  quantity     Int     @default(1)
  unitPrice    Float
  discount     Float   @default(0)
  total        Float
  notes        String?

  bill bills @relation(fields: [billId], references: [id], onDelete: Cascade)

  @@index([billId])
  @@index([itemableType, itemableId]) // Polymorphic lookup
}

model payments {
  id            String        @id @default(ulid())
  billId        String
  amount        Float
  paymentMethod PaymentMethod
  transactionId String?
  receivedBy    String? // References employees.id
  status        String        @default("success")
  paymentDate   DateTime      @default(now())
  notes         String?
  metadata      Json?

  bill               bills         @relation(fields: [billId], references: [id])
  receivedByEmployee employees?    @relation(fields: [receivedBy], references: [id])
  transaction        transactions?

  @@index([billId])
  @@index([paymentMethod])
  @@index([status])
  @@index([paymentDate]) // Daily payment reports
  @@index([receivedBy])
}

// ============= MEDICINES & PRESCRIPTIONS =============

model medicines {
  id           String   @id @default(ulid())
  name         String
  genericName  String?
  type         String?
  manufacturer String?
  strength     String?
  price        Float?
  stock        Int?
  minStock     Int?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  prescriptionItems prescription_items[]

  @@index([name])
  @@index([isActive])
  @@index([stock]) // Low stock alerts
}

model medicine_instructions {
  id          String  @id @default(ulid())
  name        String  @unique
  description String?
  isActive    Boolean @default(true)

  prescriptionItems prescription_items[]

  @@index([isActive])
}

model prescriptions {
  id            String    @id @default(ulid())
  appointmentId String
  doctorId     String // References employees.id
  notes        String?
  followUpDate DateTime?
  createdAt    DateTime  @default(now())

  appointment appointments         @relation(fields: [appointmentId], references: [id])
  doctor      employees            @relation(fields: [doctorId], references: [id])
  items       prescription_items[]

  @@index([appointmentId])
  @@index([doctorId])
  @@index([createdAt])
}

model prescription_items {
  id             String  @id @default(ulid())
  prescriptionId String
  medicineId     String
  instructionId  String?
  duration       String?
  notes          String?

  prescription prescriptions          @relation(fields: [prescriptionId], references: [id], onDelete: Cascade)
  medicine     medicines              @relation(fields: [medicineId], references: [id])
  instruction  medicine_instructions? @relation(fields: [instructionId], references: [id])

  @@index([prescriptionId])
  @@index([medicineId])
}

// ============= LABS & TESTS =============

model labs {
  id           String   @id @default(ulid())
  name         String   @unique
  code         String   @unique
  departmentId String?
  description  String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  department departments? @relation(fields: [departmentId], references: [id])
  testTypes  test_types[]

  @@index([code])
  @@index([isActive])
  @@index([departmentId])
}

model test_types {
  id          String   @id @default(ulid())
  name        String
  labId       String
  code        String   @unique
  price       Float
  templateId  String?
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  lab        labs            @relation(fields: [labId], references: [id])
  template   test_templates? @relation(fields: [templateId], references: [id])
  testOrders test_orders[]

  @@index([code])
  @@index([labId])
  @@index([isActive])
}

model test_templates {
  id          String   @id @default(ulid())
  name        String   @unique
  description String?
  fields      Json // Form builder JSON schema
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  testTypes test_types[]

  @@index([isActive])
}

model test_orders {
  id            String     @id @default(ulid())
  appointmentId String
  testTypeId String
  orderedBy  String // References employees.id
  status     TestStatus @default(ORDERED)
  priority   String     @default("normal") // "normal", "urgent", "stat"
  orderedAt  DateTime   @default(now())
  billId     String?

  appointment       appointments  @relation(fields: [appointmentId], references: [id])
  testType          test_types    @relation(fields: [testTypeId], references: [id])
  orderedByEmployee employees     @relation("OrderedBy", fields: [orderedBy], references: [id])
  result            test_results?

  @@index([appointmentId])
  @@index([testTypeId, status]) // Lab queue
  @@index([status, orderedAt]) // Workflow status
  @@index([orderedAt]) // Recent orders
  @@index([orderedBy])
  @@index([priority]) // Urgent tests first
}

model test_results {
  id           String     @id @default(ulid())
  testOrderId  String     @unique
  technicianId String // References employees.id
  resultData   Json // Dynamic form data
  status       TestStatus @default(IN_PROGRESS)
  reviewedBy   String? // References employees.id
  reviewNotes  String?
  completedAt  DateTime?
  releasedAt   DateTime?
  deliveredAt  DateTime?
  deliveredTo  String?

  testOrder  test_orders @relation(fields: [testOrderId], references: [id])
  technician employees   @relation("Technician", fields: [technicianId], references: [id])
  reviewer   employees?  @relation("Reviewer", fields: [reviewedBy], references: [id])

  @@index([status, completedAt]) // Pending review
  @@index([technicianId])
  @@index([reviewedBy])
}

// ============= DOCUMENTS =============

model documents {
  id            String   @id @default(ulid())
  patientId     String
  appointmentId String?
  fileType   String // "xray", "scan", "report", "prescription"
  fileName   String
  fileUrl    String
  fileSize   Int?
  uploadedBy String
  uploadedAt DateTime @default(now())

  patient        patients @relation(fields: [patientId], references: [id])
  uploadedByUser users    @relation(fields: [uploadedBy], references: [id])

  @@index([patientId])
  @@index([appointmentId])
  @@index([fileType])
  @@index([uploadedAt])
}

// ============= NOTIFICATIONS =============

model notifications {
  id        String           @id @default(ulid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  user users @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead, createdAt]) // Unread notifications
  @@index([createdAt])
}

// ============= LEDGER ACCOUNTS =============

model ledger_accounts {
  id          String   @id @default(ulid())
  name        String
  accountType String // "cash", "bank", "revenue", "expense" - flexible
  balance     Float    @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  transactions transactions[]

  @@index([accountType])
  @@index([isActive])
}

model transactions {
  id            String   @id @default(ulid())
  accountId     String
  paymentId     String?  @unique
  amount        Float
  type          String // "CREDIT", "DEBIT"
  referenceType String? // "bill", "expense", "transfer" - flexible
  referenceId   String?
  description   String?
  createdAt     DateTime @default(now())

  account ledger_accounts @relation(fields: [accountId], references: [id])
  payment payments?       @relation(fields: [paymentId], references: [id])

  @@index([accountId, createdAt]) // Account statement
  @@index([createdAt]) // Daily transactions
  @@index([referenceType, referenceId]) // Lookup by reference
}

// ============= SETTINGS =============

model settings {
  id        String   @id @default(ulid())
  key       String   @unique
  value     String // Store JSON or encrypted values
  type      String   @default("string") // "string", "number", "boolean", "json"
  isPublic  Boolean  @default(false) // Can be accessed by frontend
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key])
  @@index([isPublic])
}

// ============= AUDIT LOG (For compliance & debugging) =============

model audit_logs {
  id        String   @id @default(ulid())
  userId    String?
  action    String // "create", "update", "delete", "login", etc.
  entity    String // "patient", "visit", "bill", etc.
  entityId  String?
  changes   Json? // Before/after data
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([entity, entityId])
  @@index([createdAt]) // Archiving old logs
  @@index([action])
}

// ============= LEGACY (Keep for now) =============

model categories {
  id          String   @id @default(ulid())
  title       String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
